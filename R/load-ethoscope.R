#' Load data from ethoscope result files
#'
#' This function is used to import behavioural data generated
#' by the [ethoscope platform](http://gilestrolab.github.io/ethoscope/).
#' That is it loads multiple `.db` files into a single `R` [fslbehavr::behavr] table.
#'
#' @param metadata [data.table::data.table] used to load data (see detail)
#' @param min_time,max_time load only data between `min_time` and `max_time` (in seconds).
#' This time is *relative to the start of the experiment*.
#' @param reference_hour hour, in the day, to use as ZT0 reference.
#' When unspecified, time will be relative to the start of the experiment.
#' @param verbose whether to print progress (a logical)
#' @param columns optional vector of columns to be selected from the db file.
#' Time (t) is always implicitly selected.
#' When `NULL` and if `FUN` is set, columns can be retrieved automatically (from the attributes of `FUN`).
#' @param cache the name of a local directory to cache results for faster subsequent data loading.
#' @param ncores number of cores to use for optional parallel processing (experimental).
#' @param FUN function (optional) to transform the data from each individual
#' immediately after is has been loaded.
#' @param ... extra arguments to be passed to `FUN`
#' @param map_arg  OPTIONAL a list to map `FUN` arguments to metavariables values. See details
#' @param progress OPTIONAL A shiny::Progress instance that reports status to the UI
#' @return A [behavr] table.
#' In addition to the metadata, it contains the data, with the columns:
#' * `id` -- autogenerated unique identifier, one per animal
#' * `t` -- time (s)
#' * Several variables recorded by ethoscopes (position, angle, width/height and others), or computed by `FUN`.
#' Distance units (e.g. xy position, height/width) are expressed as a fraction of the width of the ROI they originate from.
#' @details
#' the linked metadata should be generated using [link_ethoscope_metadata].
#' `map_arg` is a list of the form `list(fun_arg = "metavariable")`.
#' When provided, `FUN` will set specific arguments (`fun_arg`) to the value of a (quoted) metavariable.
#'
#' @examples
#' dir <- paste0(scopr_example_dir(), "/ethoscope_results/")
#' data(region_id_metadata)
#' metadata <- link_ethoscope_metadata(region_id_metadata, dir)
#' print(metadata)
#'
#' # Default data loading
#' dt <- load_ethoscope(metadata)
#' dt
#'
#' # We use reference hour to set zt0 to 09:00 GMT
#' dt <- load_ethoscope(metadata, reference_hour=9)
#' dt
#'
#' # Only load x and y positions
#' dt <- load_ethoscope(metadata, columns=c("x", "y"), reference_hour=9)
#' dt
#' # apply function whilst loading the data
#' dt <- load_ethoscope(metadata, reference_hour=9, FUN=head)
#' dt
#'
#' @seealso
#' Take the mode of a distribution
#' * [fslbehavr::behavr] -- to understand the output format
#' * [experiment_info] -- to show information about a file/experiment
#' * [list_result_files] -- to list available files
#' @references
#' * [behavr tutorial](https://rethomics.github.io/behavr.html) -- how to work with the obtained [behavr] table
#' @export
load_ethoscope <- function(metadata,
                           min_time = 0,
                           max_time = Inf,
                           reference_hour = NULL,
                           verbose = TRUE,
                           columns = NULL,
                           cache = NULL,
                           ncores = 1,
                           FUN = NULL,
                           map_arg = NULL,
                           ...){

  file_info = NULL


  # FIXME Find a better way of counting how many unique flies
  # are there in the metadata
  # This probably is suboptimal
  experiment_id <- metadata[, sapply(file_info, function(x) x$path)]
  metadata$fly_count <- as.integer(rownames(metadata))
  q_l <- split(metadata, experiment_id)
  # total_count <- nrow(do.call(what = rbind, q_l))

  # Declare a closure taking a user provided query
  # i.e. a metadata table
  load_fun <- function(q){

    # Each row of metadata refers to a unique fly.
    # To each row we apply the function `parse_single_roi`
    # and get the data for the corresponding fly in a behavr table object
    # So, l_dt is a list of behavr tables, one per fly.
    # If no data is available for a fly, the list element is `NULL`.
    data.table::setkeyv(q, data.table::key(metadata))

    # Make the metadata compatible with lapply
    # by making it a list of rows
    l_rows <- lapply(1:nrow(q), function(i) { q[i,] })


    parse_wrapper <- function(row){

      # initialize a list of arguments to parse_single_roi
      arg_list = list(row,
                      min_time = min_time,
                      max_time = max_time,
                      verbose = verbose,
                      columns = columns,
                      cache = cache,
                      FUN = FUN,
                      ...
                      )

      # if reference_hour is NA, the user wants to get the reference_hour
      # from the metadata
      message(sprintf('Reference hour is set to %s', reference_hour))


      if(!is.null(reference_hour)) {
        if (is.na(reference_hour)) map_arg <- c(map_arg, reference_hour = "reference_hour")

        # if it is not NA, use the reference_hour argument passed to load_ethoscope
      } else if (is.null(reference_hour)) {
        arg_list <- c(arg_list, reference_hour = NULL)
      }  else {
        arg_list <- c(arg_list, reference_hour = reference_hour)
      }


      # create an additional list by parsing the elements in map_arg
      # and mapping them to the right column in row
      #
      # for each key-val pair in map_arg
      # assign to column key the value val

      arg_val = lapply(map_arg, function(x) {
        # with=F means select the column matching the content of
        # as opposed to a column called x
        unname(unlist(row[, x, with = F]))
        # unlist to return a vector
        # unname to make it an unnamed vector
        # i.e. just a scalar
      })

      # combine the parsed arg_val with the
      # already available arg_list
      arg_list <- c(arg_list, arg_val)

      dups <- duplicated(names(arg_list))
      if(any(dups)) {
        duplicate_args <- names(arg_list)[dups]
        arg_list <- arg_list[!dups]
        for (d in duplicate_args) {
          warning(sprintf("argument %s was passed more than once", d))
          warning(sprintf("I will use value %s", arg_list[d]))
        }
      }


      # call parse_single_roi with this combined list of arguments
      do.call(parse_single_roi, arg_list)
    } # end of parse_wrapper

    # call parse_single_roi with l_rows combined with the arguments
    # parsed from the metadata file
    l_dt <- lapply(l_rows, parse_wrapper)

    # restore a behavr table from a list of behavr tables
    # each element is the behavr table of a single fly
    res <- fslbehavr::bind_behavr_list(l_dt)
    return(res)

  } # end of load_fun

  # Call load_fun in parallel or unithreaded
  # depending on the value of ncores
  if(ncores == 1){

    l_dt <- lapply(1:length(q_l), function(i) load_fun(q_l[[i]]))

  } else{

      if (!requireNamespace("parallel", quietly = TRUE)) {
      stop("`parallel` package needed for ncores > 1.
           Please install it.",
           call. = FALSE)
    }
    l_dt <- parallel::mclapply(1:length(q_l), function(i) load_fun(q_l[[i]]), mc.cores=ncores)
  }

  # TODO This call to bind_behavr_list coerces a list of length 1
  # so maybe just unlist or [[1]] would be enough
  dt <- fslbehavr::bind_behavr_list(l_dt)

  # Get rid of temporary data containers not needed anymore
  # Force R to garbage collect, making memory available
  rm(l_dt)
  gc()

  # finally, annotate the phase based on T
  # if t is within the first 12 hours of each 24 hour cycle,
  # phase is L (Light)
  # otherwise phase is D (Dark)
  message("Computing phase")
  dt[, phase := ifelse(t %% hours(24) > hours(12), 'D', 'L')]

  return(dt)
}

